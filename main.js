/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Translator"] = factory();
	else
		root["Translator"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@tokey/core/dist/core.js":
/*!***********************************************!*\
  !*** ./node_modules/@tokey/core/dist/core.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tokenize = void 0;\nfunction tokenize(source, { isDelimiter, isStringDelimiter, isWhitespace, shouldAddToken, createToken, getCommentStartType, isCommentEnd, getUnclosedComment, offset = 0, }) {\n    const tokens = [];\n    let previousChar = \"\";\n    let buffer = \"\";\n    let inComment = \"\";\n    let inString = \"\";\n    let start = offset;\n    let nextCharIndex = 0;\n    for (const ch of source) {\n        nextCharIndex += ch.length;\n        if (inString) {\n            buffer += ch;\n            if (ch === inString && previousChar !== \"\\\\\") {\n                pushBuffer(\"string\");\n                inString = \"\";\n            }\n        }\n        else if (inComment) {\n            buffer += ch;\n            if (isCommentEnd(inComment, ch, source, nextCharIndex, previousChar)) {\n                pushBuffer(inComment);\n                inComment = \"\";\n            }\n        }\n        else if ((inComment = getCommentStartType(ch, source, nextCharIndex))) {\n            pushBuffer();\n            buffer += ch;\n        }\n        else if (isStringDelimiter(ch, previousChar)) {\n            pushBuffer();\n            buffer += ch;\n            inString = ch;\n        }\n        else if (isDelimiter(ch, previousChar)) {\n            pushBuffer();\n            buffer += ch;\n            pushBuffer(ch);\n        }\n        else if (isWhitespace(ch) && !isWhitespace(previousChar)) {\n            pushBuffer();\n            buffer += ch;\n        }\n        else if (!isWhitespace(ch) && isWhitespace(previousChar)) {\n            pushBuffer();\n            buffer += ch;\n        }\n        else {\n            buffer += ch;\n        }\n        previousChar = ch;\n    }\n    if (buffer.length) {\n        if (inComment) {\n            pushBuffer(getUnclosedComment(inComment));\n        }\n        else if (inString) {\n            pushBuffer(\"unclosed-string\");\n        }\n        else {\n            pushBuffer();\n        }\n    }\n    function pushBuffer(type) {\n        if (buffer.length === 0) {\n            return;\n        }\n        const end = start + buffer.length;\n        type = type !== null && type !== void 0 ? type : (buffer.trim().length ? \"text\" : \"space\");\n        if (shouldAddToken(type, buffer)) {\n            tokens[tokens.length] = createToken(buffer, type, start, end);\n        }\n        start = end;\n        buffer = \"\";\n    }\n    return tokens;\n}\nexports.tokenize = tokenize;\n//# sourceMappingURL=core.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/core/dist/core.js?");

/***/ }),

/***/ "./node_modules/@tokey/core/dist/helpers.js":
/*!**************************************************!*\
  !*** ./node_modules/@tokey/core/dist/helpers.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.last = exports.trimTokens = exports.groupTokens = exports.getText = exports.getUnclosedComment = exports.isCommentEnd = exports.getMultilineCommentStartType = exports.getJSCommentStartType = exports.createToken = exports.isWhitespace = exports.isStringDelimiter = exports.isString = exports.isComment = void 0;\n/**\n * Checks if a token type is comment\n */\nfunction isComment(type) {\n    return (type === \"line-comment\" ||\n        type === \"multi-comment\" ||\n        type === \"unclosed-comment\");\n}\nexports.isComment = isComment;\n/**\n * Checks if a token type is string\n */\nfunction isString(type) {\n    return type === \"string\" || type === \"unclosed-string\";\n}\nexports.isString = isString;\n/**\n * Checks for a set of JS strings\n */\nconst isStringDelimiter = (char) => char === `'` || char === `\"` || char === \"`\";\nexports.isStringDelimiter = isStringDelimiter;\n/**\n * Checks for a set of Whitespace\n */\nconst isWhitespace = (char) => char === \" \" || char === `\\t` || char === `\\r` || char === \"\\n\";\nexports.isWhitespace = isWhitespace;\n/**\n * Creates a basic token\n */\nconst createToken = (value, type, start, end) => {\n    return {\n        value,\n        type,\n        start,\n        end,\n    };\n};\nexports.createToken = createToken;\n/**\n * Get JS type of comments for a specific set of start chars when no comment is detected empty string is used\n */\nfunction getJSCommentStartType(ch, source, nextCharIndex) {\n    if (ch === \"/\" && source[nextCharIndex] === \"/\") {\n        return \"line-comment\";\n    }\n    else {\n        return ch === \"/\" && source[nextCharIndex] === \"*\" ? \"multi-comment\" : \"\";\n    }\n}\nexports.getJSCommentStartType = getJSCommentStartType;\n/**\n * Get CSS type of comments for a specific set of start chars when no comment is detected empty string is used\n */\nfunction getMultilineCommentStartType(ch, source, nextCharIndex) {\n    return ch === \"/\" && source[nextCharIndex] === \"*\" ? \"multi-comment\" : \"\";\n}\nexports.getMultilineCommentStartType = getMultilineCommentStartType;\n/**\n * Given a JS comment type determine if this is the end of the comment\n */\nfunction isCommentEnd(commentType, ch, _source, _nextCharIndex, previousChar) {\n    if (commentType === \"line-comment\" && ch === \"\\n\") {\n        return true;\n    }\n    else if (commentType === \"multi-comment\" &&\n        ch === \"/\" &&\n        previousChar === \"*\") {\n        return true;\n    }\n    return false;\n}\nexports.isCommentEnd = isCommentEnd;\n/**\n * Get the type of unclosed comment\n */\nfunction getUnclosedComment(commentType) {\n    if (commentType === \"line-comment\") {\n        return commentType;\n    }\n    else {\n        return \"unclosed-comment\";\n    }\n}\nexports.getUnclosedComment = getUnclosedComment;\n/**\n * Get the text between two token indexes\n * if source is provided it will slice the text from original source\n * otherwise the value of the tokens will be concatenated\n */\nfunction getText(tokens, startIndex = 0, upToIndex = -1, source) {\n    if (tokens.length === 0) {\n        return \"\";\n    }\n    if (upToIndex === -1) {\n        upToIndex = tokens.length;\n    }\n    if (source) {\n        return source.slice(tokens[startIndex].start, tokens[upToIndex - 1].end);\n    }\n    else {\n        let res = \"\";\n        for (let i = startIndex; i < upToIndex; i++) {\n            res += tokens[i].value;\n        }\n        return res;\n    }\n}\nexports.getText = getText;\n/**\n * Takes an array of tokens and group them into a single token.\n * If source is provided the value will contain the text between the tokens,\n * instead of the tokens concatenated text.\n */\nfunction groupTokens(tokens, type = \"tokens\", source) {\n    return {\n        type,\n        start: tokens[0].start,\n        end: tokens[tokens.length - 1].end,\n        value: getText(tokens, undefined, undefined, source),\n        tokens,\n    };\n}\nexports.groupTokens = groupTokens;\n/**\n * Trim tokens from both ends with a matcher function\n */\nfunction trimTokens(tokens, shouldTrimToken) {\n    let start = 0;\n    let end = tokens.length;\n    for (let i = 0; i < tokens.length; i++) {\n        if (shouldTrimToken(tokens[i])) {\n            start = i + 1;\n        }\n        else {\n            break;\n        }\n    }\n    for (let i = tokens.length - 1; i > start; i--) {\n        if (shouldTrimToken(tokens[i])) {\n            end = i;\n        }\n        else {\n            break;\n        }\n    }\n    return tokens.slice(start, end);\n}\nexports.trimTokens = trimTokens;\n/**\n * get last item in array\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexports.last = last;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/core/dist/helpers.js?");

/***/ }),

/***/ "./node_modules/@tokey/core/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/@tokey/core/dist/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/@tokey/core/dist/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core */ \"./node_modules/@tokey/core/dist/core.js\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers */ \"./node_modules/@tokey/core/dist/helpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./seeker */ \"./node_modules/@tokey/core/dist/seeker.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/core/dist/index.js?");

/***/ }),

/***/ "./node_modules/@tokey/core/dist/seeker.js":
/*!*************************************************!*\
  !*** ./node_modules/@tokey/core/dist/seeker.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Seeker = void 0;\n/**\n * Minimal token traverse helper used to create structure from tokens\n */\nclass Seeker {\n    constructor(tokens) {\n        this.tokens = tokens;\n        this.index = -1;\n    }\n    next() {\n        this.index++;\n        return this.tokens[this.index] || { type: \"\" };\n    }\n    back() {\n        this.index--;\n    }\n    peekBack() {\n        return this.tokens[this.index - 1] || { type: \"\" };\n    }\n    peek(num = 1) {\n        return this.tokens[this.index + num] || { type: \"\" };\n    }\n    take(type) {\n        if (this.peek().type === type) {\n            return this.next();\n        }\n        return undefined;\n    }\n    takeMany(type) {\n        const tokens = [];\n        while (this.peek().type === type) {\n            tokens.push(this.next());\n        }\n        return tokens;\n    }\n    flatBlock(start, end, isEndError) {\n        let token = this.next();\n        if (token.type !== start) {\n            return [];\n        }\n        const block = [];\n        let endIndex;\n        while ((token = this.next())) {\n            if (!token.type) {\n                if (endIndex !== undefined) {\n                    this.index = endIndex - 1;\n                }\n                return;\n            }\n            if (isEndError && isEndError(token)) {\n                endIndex = this.index;\n            }\n            if (token.type === end) {\n                return block;\n            }\n            else {\n                block.push(token);\n            }\n        }\n        return [];\n    }\n    done() {\n        return this.index >= this.tokens.length - 1;\n    }\n    run(handleToken, ast, source) {\n        let token;\n        while ((token = this.next()) && token.type) {\n            if (handleToken(token, ast, source, this) === false) {\n                break;\n            }\n        }\n        return ast;\n    }\n}\nexports.Seeker = Seeker;\n//# sourceMappingURL=seeker.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/core/dist/seeker.js?");

/***/ }),

/***/ "./node_modules/@tokey/core/dist/types.js":
/*!************************************************!*\
  !*** ./node_modules/@tokey/core/dist/types.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/core/dist/types.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/ast-tools/compound.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/ast-tools/compound.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.splitCompoundSelectors = exports.groupCompoundSelectors = void 0;\nconst walk_1 = __webpack_require__(/*! ./walk */ \"./node_modules/@tokey/css-selector-parser/dist/ast-tools/walk.js\");\nfunction groupCompoundSelectors(input, options) {\n    const context = createCompoundContext(options);\n    (0, walk_1.walk)(input, (node, _index, _nodes, parents) => {\n        if (parents.length === 0 && node.type === `selector`) {\n            // first level: create top level selector\n            context.addSelector(node);\n        }\n        else {\n            // second level: (parents.length === 1)\n            context.handleNode(node);\n            // don't go deeper - shallow group\n            return walk_1.walk.skipNested;\n        }\n        return;\n    });\n    return `length` in input ? context.output : context.output[0];\n}\nexports.groupCompoundSelectors = groupCompoundSelectors;\nfunction createCompoundContext({ splitPseudoElements = true, } = {}) {\n    const output = [];\n    let lastSelector;\n    let lastCompound;\n    let lastCompoundInitialPart;\n    const handleNode = (node) => {\n        if (node.type === `pseudo_element` && splitPseudoElements === true) {\n            lastCompound = undefined;\n        }\n        if (node.type === `combinator`) {\n            lastSelector.nodes.push(node);\n            lastCompound = undefined;\n        }\n        else if (node.type === `comment` && !isCommentWithNoSpacing(node)) {\n            // comment that breaks compound\n            lastSelector.nodes.push(node);\n            lastCompound = undefined;\n        }\n        else if (node.type === `type` ||\n            node.type === `universal` ||\n            node.type === `class` ||\n            node.type === `id` ||\n            node.type === `attribute` ||\n            node.type === `nesting` ||\n            node.type === `pseudo_class` ||\n            node.type === `pseudo_element` ||\n            node.type === `invalid` ||\n            node.type === `comment` /*no spacing*/) {\n            // part of compound\n            if (!lastCompound) {\n                // add new compound selector\n                lastCompoundInitialPart = undefined;\n                lastCompound = {\n                    type: `compound_selector`,\n                    start: node.start,\n                    end: node.end,\n                    before: ``,\n                    after: ``,\n                    nodes: [],\n                    invalid: false,\n                };\n                lastSelector.nodes.push(lastCompound);\n            }\n            if (!lastCompound.invalid && node.type !== `comment`) {\n                // validate compound parts after initial\n                if (lastCompoundInitialPart) {\n                    lastCompound.invalid =\n                        node.type === `universal` || node.type === `type`;\n                }\n                lastCompoundInitialPart = node;\n            }\n            lastCompound.nodes.push(node);\n            lastCompound.end = node.end;\n        }\n        else if (node.type === `selector` || node.type === `compound_selector`) {\n            // spread\n            for (const innerNode of node.nodes) {\n                handleNode(innerNode);\n            }\n        }\n        else {\n            // handle out of context nodes\n            lastSelector.nodes.push(node);\n            lastCompound = undefined;\n        }\n    };\n    return {\n        addSelector(node) {\n            lastSelector = {\n                type: `selector`,\n                start: node.start,\n                end: node.end,\n                before: `before` in node ? node.before : ``,\n                after: `after` in node ? node.after : ``,\n                nodes: [],\n            };\n            output.push(lastSelector);\n            lastCompound = undefined;\n        },\n        handleNode,\n        output,\n    };\n}\nfunction splitCompoundSelectors(input) {\n    const inputSelectors = Array.isArray(input) ? input : [input];\n    const output = [];\n    for (const inputSelector of inputSelectors) {\n        const outputSelector = {\n            ...inputSelector,\n            nodes: [],\n        };\n        for (const node of inputSelector.nodes) {\n            if (node.type === `compound_selector`) {\n                outputSelector.nodes.push(...node.nodes);\n            }\n            else {\n                outputSelector.nodes.push(node);\n            }\n        }\n        output.push(outputSelector);\n    }\n    return `length` in input ? output : output[0];\n}\nexports.splitCompoundSelectors = splitCompoundSelectors;\nfunction isCommentWithNoSpacing(node) {\n    return node.type === `comment` && node.before === `` && node.after === ``;\n}\n//# sourceMappingURL=compound.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/ast-tools/compound.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/ast-tools/specificity.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/ast-tools/specificity.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compareSpecificity = exports.calcSpecificity = void 0;\nconst walk_1 = __webpack_require__(/*! ./walk */ \"./node_modules/@tokey/css-selector-parser/dist/ast-tools/walk.js\");\nfunction calcSpecificity(ast) {\n    const result = [0, 0, 0, 0];\n    // ToDo: remove casting once immutable walk is supported\n    (0, walk_1.walk)(ast, (node) => {\n        switch (node.type) {\n            case `type`:\n            case `pseudo_element`:\n                result[3]++;\n                break;\n            case `class`:\n            case `attribute`:\n                result[2]++;\n                break;\n            case `pseudo_class`:\n                if (customPseudoClass[node.value]) {\n                    customPseudoClass[node.value](node, result);\n                    return walk_1.walk.skipNested;\n                }\n                result[2]++;\n                break;\n            case `id`:\n                result[1]++;\n                break;\n        }\n        return node.type !== `selector` && node.type !== `compound_selector`\n            ? walk_1.walk.skipNested\n            : undefined;\n    });\n    return result;\n}\nexports.calcSpecificity = calcSpecificity;\nconst customPseudoClass = {\n    not: mostSpecificInnerSelector,\n    is: mostSpecificInnerSelector,\n    has: mostSpecificInnerSelector,\n    where: () => {\n        /* no specificity*/\n    },\n    \"nth-child\": pseudoClassPlusMostSpecificInnerSelector,\n    \"nth-last-child\": pseudoClassPlusMostSpecificInnerSelector,\n    \"nth-of-type\": pseudoClassPlusMostSpecificInnerSelector,\n    \"nth-last-of-type\": pseudoClassPlusMostSpecificInnerSelector,\n};\nfunction pseudoClassPlusMostSpecificInnerSelector(node, result) {\n    result[2]++;\n    mostSpecificInnerSelector(node, result);\n}\nfunction mostSpecificInnerSelector(node, result) {\n    var _a;\n    if ((_a = node.nodes) === null || _a === void 0 ? void 0 : _a.length) {\n        let highest = [0, 0, 0, 0];\n        for (const selector of node.nodes) {\n            const currentSpecificity = calcSpecificity(selector);\n            if (!highest || compareSpecificity(currentSpecificity, highest) === 1) {\n                highest = currentSpecificity;\n            }\n        }\n        addSpecificity(result, highest);\n    }\n}\n/**\n * compare 2 specificities\n * @param a first specificity\n * @param b second specificity\n * @returns 0 if equal, 1 when a is more specific, -1 when b is more specific\n */\nfunction compareSpecificity(a, b) {\n    for (let i = 0; i < 4; ++i) {\n        const specificityDiff = a[i] - b[i];\n        if (specificityDiff > 0) {\n            return 1;\n        }\n        else if (specificityDiff < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\nexports.compareSpecificity = compareSpecificity;\n/**\n * mutate the first value, adding the second one\n * @param to specificity reference to to\n * @param from specificity amount to add\n */\nfunction addSpecificity(to, from) {\n    for (let i = 0; i < 4; ++i) {\n        to[i] += from[i];\n    }\n}\n//# sourceMappingURL=specificity.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/ast-tools/specificity.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/ast-tools/walk.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/ast-tools/walk.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.walk = void 0;\nconst nestEnd = Symbol(`nest-end`);\nfunction walk(topNode, visit, options = {}) {\n    var _a;\n    // set initial top nodes to traverse\n    const toVisit = Array.isArray(topNode) ? [...topNode] : [topNode];\n    // initiate context\n    const context = createWalkContext(topNode);\n    // iterate nodes\n    while (toVisit.length) {\n        const current = toVisit.shift();\n        if (current === nestEnd) {\n            // end of nested level\n            context.up();\n            continue;\n        }\n        else if ((!options.ignoreList || !options.ignoreList.includes(current.type)) &&\n            (!options.visitList || options.visitList.includes(current.type))) {\n            // visit node\n            let skipAmount = (_a = visit(current, context.indexInSelector, context.nodesInSelector, context.parents)) !== null && _a !== void 0 ? _a : -1;\n            // point to next selector node\n            context.next();\n            // check if to skip nested or current/following selectors\n            if (skipAmount === Infinity) {\n                // stop all: fast bail out\n                return;\n            }\n            else if (skipAmount >= 0) {\n                // skip levels\n                while (skipAmount > 0 && toVisit.length) {\n                    const next = toVisit.shift();\n                    if (next === nestEnd) {\n                        skipAmount--;\n                        context.up();\n                    }\n                }\n                continue;\n            }\n        }\n        else {\n            // point to next selector node\n            context.next();\n        }\n        // add nested nodes\n        if (isWithNodes(current)) {\n            context.insertNested(current);\n            toVisit.unshift(...current.nodes, nestEnd);\n        }\n    }\n}\nexports.walk = walk;\nfunction createWalkContext(topNode) {\n    const prevIndex = [];\n    const prevParents = [[]];\n    const context = {\n        parents: [],\n        indexInSelector: 0,\n        nodesInSelector: Array.isArray(topNode)\n            ? topNode\n            : `nodes` in topNode\n                ? topNode.nodes\n                : [topNode],\n        up() {\n            context.parents.pop();\n            context.indexInSelector = prevIndex.shift();\n            const currentParents = context.parents;\n            const currentParent = currentParents[currentParents.length - 1];\n            context.nodesInSelector = currentParent\n                ? currentParent.nodes\n                : topNode;\n        },\n        next() {\n            context.indexInSelector++;\n        },\n        insertNested(node) {\n            context.parents = [...context.parents, node];\n            prevParents.push(context.parents);\n            prevIndex.unshift(context.indexInSelector);\n            context.indexInSelector = 0;\n            context.nodesInSelector = node.nodes;\n        },\n    };\n    return context;\n}\nwalk.skipNested = 0;\nwalk.skipCurrentSelector = 1;\nwalk.stopAll = Infinity;\nfunction isWithNodes(node) {\n    return node && `nodes` in node;\n}\n//# sourceMappingURL=walk.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/ast-tools/walk.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/ast-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/ast-types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ast-types.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/ast-types.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/helpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.trimCombinators = exports.ensureSelector = exports.isNamespacedAst = exports.isNamespacedToken = exports.isCombinatorToken = exports.createCommentAst = exports.createCombinatorAst = exports.createEmptyNth = exports.createEmptySelector = void 0;\nconst core_1 = __webpack_require__(/*! @tokey/core */ \"./node_modules/@tokey/core/dist/index.js\");\n// create ast nodes\nfunction createEmptySelector() {\n    return {\n        type: \"selector\",\n        start: -1,\n        end: -1,\n        before: \"\",\n        after: \"\",\n        nodes: [],\n    };\n}\nexports.createEmptySelector = createEmptySelector;\nfunction createEmptyNth() {\n    return {\n        type: \"nth\",\n        start: -1,\n        end: -1,\n        before: \"\",\n        after: \"\",\n        nodes: [],\n    };\n}\nexports.createEmptyNth = createEmptyNth;\nfunction createCombinatorAst({ value, type, start, end, }) {\n    return {\n        type: `combinator`,\n        combinator: type,\n        value: type === `space` ? ` ` : value,\n        start,\n        end,\n        before: ``,\n        after: type === `space` ? value.slice(1) : ``,\n        invalid: false,\n    };\n}\nexports.createCombinatorAst = createCombinatorAst;\nfunction createCommentAst({ value, start, end, }) {\n    return {\n        type: `comment`,\n        value,\n        start,\n        end,\n        before: ``,\n        after: ``,\n    };\n}\nexports.createCommentAst = createCommentAst;\n// type guards\nfunction isCombinatorToken(token) {\n    return (token.type === \"space\" ||\n        token.type === \"+\" ||\n        token.type === \">\" ||\n        token.type === \"~\");\n}\nexports.isCombinatorToken = isCombinatorToken;\nfunction isNamespacedToken(token) {\n    return token.type === `*` || token.type === `text`;\n}\nexports.isNamespacedToken = isNamespacedToken;\nfunction isNamespacedAst(token) {\n    return token.type === `universal` || token.type === `type`;\n}\nexports.isNamespacedAst = isNamespacedAst;\n// utils\nfunction ensureSelector(selectors, startToken) {\n    let lastSelector = (0, core_1.last)(selectors);\n    if (!lastSelector) {\n        lastSelector = createEmptySelector();\n        lastSelector.start = startToken.start;\n        selectors.push(lastSelector);\n    }\n    return lastSelector;\n}\nexports.ensureSelector = ensureSelector;\nfunction trimCombinators(selector) {\n    // costly way to turn combinators to before and after.\n    // this can be inlined in the handle token process\n    const nodes = selector.nodes;\n    const firstNode = nodes[0];\n    const lastNode = (0, core_1.last)(nodes);\n    // remove first space combinator and add to selector before\n    // (going between comment is not required for the start becuase they are taken care\n    // of during parsing)\n    if ((firstNode === null || firstNode === void 0 ? void 0 : firstNode.type) === \"combinator\" && firstNode.combinator === \"space\") {\n        selector.nodes.shift();\n        selector.before += firstNode.before + firstNode.value + firstNode.after;\n    }\n    // remove any edge space combinators (last and between comments)\n    if (lastNode !== firstNode) {\n        let index = nodes.length - 1;\n        let current = lastNode;\n        let lastComment;\n        while ((current && current.type === `comment`) ||\n            (current.type === `combinator` && current.combinator === `space`)) {\n            if (current.type === `combinator`) {\n                if (!lastComment) {\n                    // attach space to end of selector\n                    selector.nodes.pop();\n                    selector.after += current.before + current.value + current.after;\n                }\n                else {\n                    // attach space to start of comment\n                    selector.nodes.splice(index, 1);\n                    lastComment.before += current.before + current.value + current.after;\n                    lastComment.start = current.start;\n                }\n            }\n            else {\n                lastComment = current;\n            }\n            current = nodes[--index];\n        }\n    }\n}\nexports.trimCombinators = trimCombinators;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/helpers.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compareSpecificity = exports.calcSpecificity = exports.splitCompoundSelectors = exports.groupCompoundSelectors = exports.walk = exports.stringifySelectorAst = exports.parseCssSelector = void 0;\nvar selector_parser_1 = __webpack_require__(/*! ./selector-parser */ \"./node_modules/@tokey/css-selector-parser/dist/selector-parser.js\");\nObject.defineProperty(exports, \"parseCssSelector\", ({ enumerable: true, get: function () { return selector_parser_1.parseCssSelector; } }));\n__exportStar(__webpack_require__(/*! ./ast-types */ \"./node_modules/@tokey/css-selector-parser/dist/ast-types.js\"), exports);\nvar stringify_1 = __webpack_require__(/*! ./stringify */ \"./node_modules/@tokey/css-selector-parser/dist/stringify.js\");\nObject.defineProperty(exports, \"stringifySelectorAst\", ({ enumerable: true, get: function () { return stringify_1.stringifySelectorAst; } }));\nvar walk_1 = __webpack_require__(/*! ./ast-tools/walk */ \"./node_modules/@tokey/css-selector-parser/dist/ast-tools/walk.js\");\nObject.defineProperty(exports, \"walk\", ({ enumerable: true, get: function () { return walk_1.walk; } }));\nvar compound_1 = __webpack_require__(/*! ./ast-tools/compound */ \"./node_modules/@tokey/css-selector-parser/dist/ast-tools/compound.js\");\nObject.defineProperty(exports, \"groupCompoundSelectors\", ({ enumerable: true, get: function () { return compound_1.groupCompoundSelectors; } }));\nObject.defineProperty(exports, \"splitCompoundSelectors\", ({ enumerable: true, get: function () { return compound_1.splitCompoundSelectors; } }));\nvar specificity_1 = __webpack_require__(/*! ./ast-tools/specificity */ \"./node_modules/@tokey/css-selector-parser/dist/ast-tools/specificity.js\");\nObject.defineProperty(exports, \"calcSpecificity\", ({ enumerable: true, get: function () { return specificity_1.calcSpecificity; } }));\nObject.defineProperty(exports, \"compareSpecificity\", ({ enumerable: true, get: function () { return specificity_1.compareSpecificity; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/index.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/nth-parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/nth-parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NthParser = void 0;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/@tokey/css-selector-parser/dist/helpers.js\");\nconst core_1 = __webpack_require__(/*! @tokey/core */ \"./node_modules/@tokey/core/dist/index.js\");\nclass NthParser {\n    constructor(selectorNode, s) {\n        this.selectorNode = selectorNode;\n        this.s = s;\n        this.state = `step`;\n        this.standaloneDash = false;\n        this.ast = selectorNode.nodes;\n    }\n    static isNthPseudoClass(name) {\n        return (name === `nth-child` ||\n            name === `nth-last-child` ||\n            name === `nth-of-type` ||\n            name === `nth-last-of-type`);\n    }\n    handleToken(token) {\n        const type = token.type;\n        if (type === `text` || type === `+`) {\n            switch (this.state) {\n                case `step`: {\n                    // pickup 1 or more tokens for `5n` / `+5n` / `+5n-4` / `5`\n                    const nextToken = type === `+` && this.s.peek().type === `text`\n                        ? this.s.next()\n                        : undefined;\n                    this.breakFirstChunk({\n                        type: `text`,\n                        value: token.value + ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.value) || ``),\n                        start: token.start,\n                        end: (nextToken === null || nextToken === void 0 ? void 0 : nextToken.end) || token.end,\n                    });\n                    return true;\n                }\n                case `dash`: {\n                    const nextToken = type === `+` && this.s.peek().type === `text`\n                        ? this.s.next()\n                        : undefined;\n                    this.pushDash({\n                        type: `text`,\n                        value: token.value + ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.value) || ``),\n                        start: token.start,\n                        end: (nextToken === null || nextToken === void 0 ? void 0 : nextToken.end) || token.end,\n                    });\n                    return true;\n                }\n                case `offset`: {\n                    const nextToken = type === `+` && this.s.peek().type === `text`\n                        ? this.s.next()\n                        : undefined;\n                    this.pushOffset({\n                        type: `text`,\n                        value: token.value + ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.value) || ``),\n                        start: token.start,\n                        end: (nextToken === null || nextToken === void 0 ? void 0 : nextToken.end) || token.end,\n                    });\n                    return true;\n                }\n                case `of`: {\n                    this.pushOf(token);\n                    return false;\n                }\n            }\n        }\n        else if (type === `space`) {\n            // improve typing\n            const lastNode = (0, core_1.last)(this.ast);\n            if (lastNode) {\n                lastNode.after += token.value;\n                lastNode.end += token.value.length;\n            }\n            else {\n                // add initial space to top selector\n                this.selectorNode.before += token.value;\n            }\n            return true;\n        }\n        else if ((0, core_1.isComment)(type)) {\n            this.ast.push((0, helpers_1.createCommentAst)(token));\n            return true;\n        }\n        // not part of `An+b of`: bail out\n        this.s.back();\n        return false;\n    }\n    /**\n     * first token can only be (minus contained in text):\n     * step: `5n`/`+5n`/`-5n`\n     * step & offset: `5n`/`5n-5\n     */\n    breakFirstChunk(token) {\n        const value = token.value;\n        // find odd/even\n        const oddEventMatch = value.match(NthParser.oddEvenStep);\n        if (oddEventMatch) {\n            const isInvalid = !!oddEventMatch[1];\n            this.pushStep(token, isInvalid);\n            return;\n        }\n        // separate valid step start from rest: `-5n-4` / `-5n` / `-4` / `5n-4`\n        const matchValidStart = value.match(NthParser.nthStartExp);\n        if (!matchValidStart) {\n            // invalid step\n            this.pushStep(token);\n        }\n        else {\n            const step = matchValidStart[1];\n            const offset = matchValidStart[2];\n            if (!offset &&\n                !step.match(/[nN]+$/) &&\n                step.match(NthParser.validOffset)) {\n                // no `n` - just offset\n                this.pushOffset(token);\n            }\n            else if (offset === `-`) {\n                // connected dash: `5n-`\n                this.pushStep({\n                    type: `text`,\n                    value: step,\n                    start: token.start,\n                    end: token.start + step.length,\n                });\n                this.pushDash({\n                    type: `text`,\n                    value: `-`,\n                    start: token.end - 1,\n                    end: token.end,\n                });\n            }\n            else if (offset && !offset.match(/-\\d+/)) {\n                // invalid step: `-3x`\n                this.pushStep(token);\n            }\n            else {\n                // step with potential minus offset: `5n-4`\n                this.pushStep({\n                    type: `text`,\n                    value: step,\n                    start: token.start,\n                    end: token.start + step.length,\n                });\n                if (offset) {\n                    this.pushOffset({\n                        type: `text`,\n                        value: offset,\n                        start: token.end - offset.length,\n                        end: token.end,\n                    });\n                }\n            }\n        }\n    }\n    pushStep(token, isInvalid) {\n        const value = token.value;\n        const stepNode = {\n            type: `nth_step`,\n            value,\n            before: ``,\n            after: ``,\n            start: token.start,\n            end: token.end,\n        };\n        isInvalid =\n            isInvalid !== undefined ? isInvalid : !value.match(NthParser.validStep);\n        if (isInvalid) {\n            stepNode.invalid = true;\n        }\n        this.state = `dash`;\n        this.ast.push(stepNode);\n    }\n    pushDash(token) {\n        const value = token.value;\n        if (value === `+` || value === `-`) {\n            this.ast.push({\n                type: `nth_dash`,\n                value: token.value,\n                start: token.start,\n                end: token.end,\n                before: ``,\n                after: ``,\n            });\n            this.standaloneDash = true;\n            this.state = `offset`;\n        }\n        else {\n            this.pushOffset(token);\n        }\n    }\n    pushOffset(token) {\n        if (token.value === `of`) {\n            this.pushOf(token);\n        }\n        else {\n            const value = token.value;\n            const offsetNode = {\n                type: `nth_offset`,\n                value,\n                before: ``,\n                after: ``,\n                start: token.start,\n                end: token.end,\n            };\n            if (!value.match(NthParser.validOffset) ||\n                (this.standaloneDash && value.match(/^[-+]/))) {\n                offsetNode.invalid = true;\n            }\n            this.state = `of`;\n            this.ast.push(offsetNode);\n        }\n    }\n    pushOf(token) {\n        const ofNode = {\n            type: `nth_of`,\n            value: token.value,\n            before: ``,\n            after: ``,\n            start: token.start,\n            end: token.end,\n        };\n        if (token.value !== `of`) {\n            ofNode.invalid = true;\n        }\n        this.ast.push(ofNode);\n        this.state = `selector`;\n    }\n}\nexports.NthParser = NthParser;\n/**\n * check (case insensitive) and returns 2 groups:\n * 1. plus/minus sign (invalid step value)\n * 2. odd/even string\n * [\n *  `+`|`-`|undefined,\n *  `odd`|`even`\n * ]\n */\nNthParser.oddEvenStep = /([-+]?)(odd|even)/i;\n/**\n * check for valid step\n * starts with optional minus or plus,\n * ends with 0 or more digits following a `n`/`N` character\n */\nNthParser.validStep = /^[-+]?\\d*n$/i;\n/**\n * check for valid offset\n * starts with optional minus or plus,\n * ends with 1 or more digits\n */\nNthParser.validOffset = /^[-+]?\\d+$/;\n/**\n * check for valid start of nth expression\n * and returns 2 groups:\n * 1. An: optional minus or plus, 0 or more digits, `n`/`N` character\n * 2. anything after that\n */\nNthParser.nthStartExp = /([-+]?\\d*[nN]?)(.*)/;\n//# sourceMappingURL=nth-parser.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/nth-parser.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/selector-parser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/selector-parser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseCssSelector = void 0;\nconst tokenizer_1 = __webpack_require__(/*! ./tokenizer */ \"./node_modules/@tokey/css-selector-parser/dist/tokenizer.js\");\nconst nth_parser_1 = __webpack_require__(/*! ./nth-parser */ \"./node_modules/@tokey/css-selector-parser/dist/nth-parser.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/@tokey/css-selector-parser/dist/helpers.js\");\nconst core_1 = __webpack_require__(/*! @tokey/core */ \"./node_modules/@tokey/core/dist/index.js\");\nfunction parseCssSelector(source, options = {}) {\n    return parseTokens(source, (0, tokenizer_1.tokenizeSelector)(source, options));\n}\nexports.parseCssSelector = parseCssSelector;\nfunction parseTokens(source, tokens) {\n    return new core_1.Seeker(tokens).run(handleToken, [], source);\n}\nfunction handleToken(token, selectors, source, s) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n    let t;\n    const currentSelector = (0, helpers_1.ensureSelector)(selectors, token);\n    const ast = currentSelector.nodes;\n    if (token.type === \".\") {\n        const comments = s.takeMany(\"multi-comment\").map(helpers_1.createCommentAst);\n        const name = s.take(\"text\");\n        ast.push({\n            type: \"class\",\n            value: (_a = name === null || name === void 0 ? void 0 : name.value) !== null && _a !== void 0 ? _a : \"\",\n            start: token.start,\n            end: (_d = (_b = name === null || name === void 0 ? void 0 : name.end) !== null && _b !== void 0 ? _b : (_c = (0, core_1.last)(comments)) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : token.end,\n            dotComments: comments,\n        });\n    }\n    else if (token.type === \":\") {\n        const firstComments = s.takeMany(\"multi-comment\").map(helpers_1.createCommentAst);\n        const type = s.take(\":\") || token;\n        const isClass = token === type;\n        if (isClass) {\n            const name = s.take(\"text\");\n            const endToken = name || (0, core_1.last)(firstComments) || type;\n            ast.push({\n                type: \"pseudo_class\",\n                value: (_e = name === null || name === void 0 ? void 0 : name.value) !== null && _e !== void 0 ? _e : \"\",\n                start: token.start,\n                end: (_f = name === null || name === void 0 ? void 0 : name.end) !== null && _f !== void 0 ? _f : endToken.end,\n                colonComments: firstComments,\n            });\n        }\n        else {\n            const secondComments = s.takeMany(\"multi-comment\").map(helpers_1.createCommentAst);\n            const name = s.take(\"text\");\n            const endToken = name || (0, core_1.last)(secondComments) || type;\n            ast.push({\n                type: \"pseudo_element\",\n                value: (_g = name === null || name === void 0 ? void 0 : name.value) !== null && _g !== void 0 ? _g : \"\",\n                start: token.start,\n                end: (_h = name === null || name === void 0 ? void 0 : name.end) !== null && _h !== void 0 ? _h : endToken.end,\n                colonComments: { first: firstComments, second: secondComments },\n            });\n        }\n    }\n    else if (token.type === \"[\") {\n        const block = s.run((token, ast) => {\n            ast.push(token);\n            return token.type !== \"]\";\n        }, [token], source);\n        const closed = ((_j = (0, core_1.last)(block)) === null || _j === void 0 ? void 0 : _j.type) === \"]\";\n        if (closed) {\n            ast.push({\n                type: \"attribute\",\n                value: block.length > 2 ? (0, core_1.getText)(block, 1, block.length - 1, source) : \"\",\n                start: token.start,\n                end: (_l = (_k = (0, core_1.last)(block)) === null || _k === void 0 ? void 0 : _k.end) !== null && _l !== void 0 ? _l : token.end,\n            });\n        }\n        else {\n            ast.push({\n                type: \"invalid\",\n                value: (0, core_1.getText)(block, undefined, undefined, source),\n                start: token.start,\n                end: (_o = (_m = (0, core_1.last)(block)) === null || _m === void 0 ? void 0 : _m.end) !== null && _o !== void 0 ? _o : token.end,\n            });\n        }\n    }\n    else if ((0, helpers_1.isCombinatorToken)(token)) {\n        let lastCombinatorAst = (0, helpers_1.createCombinatorAst)(token);\n        let lastAst = lastCombinatorAst;\n        // insert token as a combinator\n        ast.push(lastCombinatorAst);\n        // save the insertion point of the first combinator in case it's a space\n        // that might be considered a normal space later and will need to be changed.\n        let initialSpaceCombIndex = lastCombinatorAst.combinator === `space` ? ast.length - 1 : -1;\n        /**\n         * take next spaces/combinators/comments:\n         * - combinator/space token:\n         *  - spaces: merge to previous ast node before them\n         *  - previous ast equal to space combinator\n         *    - turn previous ast to the next combinator type\n         *    - merge spaces between them\n         *    - cancel initial space tracking - must be merged with other non space combinator or already canceled\n         *  - initial ast is space (must be comments following it)\n         *    - initial space is first in selector: merge initial ast into the selector before\n         *    - otherwise merge initial ast the comment following it\n         *  - insert an invalid combinator\n         * - comment token: insert to ast\n         */\n        //\n        let next = s.next();\n        while (next) {\n            if ((0, helpers_1.isCombinatorToken)(next)) {\n                if (next.type === `space`) {\n                    // add space to the last ast node\n                    lastAst.after += next.value;\n                    lastAst.end = next.end;\n                }\n                else if (lastAst === lastCombinatorAst &&\n                    lastAst.combinator === \"space\") {\n                    // combine next combinator into previous (space)\n                    const nextCombinator = (0, helpers_1.createCombinatorAst)(next);\n                    lastCombinatorAst.combinator = nextCombinator.combinator;\n                    lastCombinatorAst.before +=\n                        lastCombinatorAst.after +\n                            lastCombinatorAst.value +\n                            nextCombinator.before;\n                    lastCombinatorAst.after = nextCombinator.after;\n                    lastCombinatorAst.value = nextCombinator.value;\n                    lastCombinatorAst.end = nextCombinator.end;\n                    // reset initial space\n                    initialSpaceCombIndex = -1;\n                }\n                else if (initialSpaceCombIndex !== -1) {\n                    // merge initial space combinator (classified as combinator before a comment)\n                    const initialSpace = ast[initialSpaceCombIndex];\n                    const spaceValue = initialSpace.before + initialSpace.value + initialSpace.after;\n                    if (initialSpaceCombIndex === 0) {\n                        // merge to beginning of selector\n                        currentSelector.before += spaceValue;\n                    }\n                    else {\n                        // merge to the next comment\n                        const nodeAfterInitial = ast[initialSpaceCombIndex + 1];\n                        if ((nodeAfterInitial === null || nodeAfterInitial === void 0 ? void 0 : nodeAfterInitial.type) === `comment`) {\n                            nodeAfterInitial.before += spaceValue;\n                            nodeAfterInitial.start = initialSpace.start;\n                        }\n                        else {\n                            // shouldn't happen as initial space is considered as a combinator\n                            // only when a comment is following it and before\n                        }\n                    }\n                    ast.splice(initialSpaceCombIndex, 1);\n                    initialSpaceCombIndex = -1;\n                    // add combinator\n                    lastCombinatorAst = (0, helpers_1.createCombinatorAst)(next);\n                    lastAst = lastCombinatorAst;\n                    ast.push(lastCombinatorAst);\n                }\n                else {\n                    // add invalid combinator\n                    lastCombinatorAst = (0, helpers_1.createCombinatorAst)(next);\n                    lastCombinatorAst.invalid = true;\n                    lastAst = lastCombinatorAst;\n                    ast.push(lastCombinatorAst);\n                }\n            }\n            else if ((0, core_1.isComment)(next.type)) {\n                lastAst = (0, helpers_1.createCommentAst)(next);\n                ast.push(lastAst);\n            }\n            else {\n                break;\n            }\n            next = s.next();\n        }\n        // put back any unrelated token\n        if (next && !(0, helpers_1.isCombinatorToken)(next)) {\n            s.back();\n        }\n    }\n    else if (token.type === \"text\") {\n        ast.push({\n            type: \"type\",\n            value: token.value,\n            start: token.start,\n            end: token.end,\n        });\n    }\n    else if (token.type === \"#\") {\n        t = s.take(\"text\");\n        ast.push({\n            type: \"id\",\n            value: (_p = t === null || t === void 0 ? void 0 : t.value) !== null && _p !== void 0 ? _p : \"\",\n            start: token.start,\n            end: (_q = t === null || t === void 0 ? void 0 : t.end) !== null && _q !== void 0 ? _q : token.end,\n        });\n    }\n    else if (token.type === \"*\") {\n        ast.push({\n            type: \"universal\",\n            value: \"*\",\n            start: token.start,\n            end: token.end,\n        });\n    }\n    else if (token.type === \"|\") {\n        // search backwards compatible namespace in ast\n        let prevAst;\n        let prevInvalidAst;\n        const beforeComments = [];\n        for (let i = ast.length - 1; i >= 0; --i) {\n            const current = ast[i];\n            if ((0, helpers_1.isNamespacedAst)(current)) {\n                if (current.namespace) {\n                    // already namespaced\n                    prevInvalidAst = current;\n                }\n                else {\n                    // merge with previous\n                    prevAst = current;\n                }\n                break;\n            }\n            else if (current.type === `comment` &&\n                current.before === `` &&\n                current.after === ``) {\n                beforeComments.unshift(current);\n            }\n            else {\n                prevInvalidAst = current;\n                break;\n            }\n        }\n        // search forward target token\n        let target;\n        let searchIndex = 1;\n        const potentialAfterComments = [];\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const nextToken = s.peek(searchIndex);\n            if ((0, core_1.isComment)(nextToken.type)) {\n                potentialAfterComments.push(nextToken);\n            }\n            else if ((0, helpers_1.isNamespacedToken)(nextToken)) {\n                target = nextToken;\n                break;\n            }\n            else {\n                // space or end of tokens\n                break;\n            }\n            searchIndex++;\n        }\n        // create/update ast\n        const validNamespace = !prevInvalidAst;\n        const validTarget = !!target;\n        const type = (target === null || target === void 0 ? void 0 : target.type) === `*` ? `universal` : `type`;\n        let invalid = ``;\n        // remove before/after pipe comments\n        if (validNamespace) {\n            ast.splice(ast.length - beforeComments.length, beforeComments.length);\n        }\n        else {\n            invalid = `namespace`;\n        }\n        if (validTarget) {\n            potentialAfterComments.forEach(() => s.next());\n            s.next();\n        }\n        else {\n            invalid = invalid ? `namespace,target` : `target`;\n        }\n        // create new ast or modify the prev\n        const nsAst = prevAst ||\n            {\n                type,\n                value: ``,\n                start: token.start,\n                end: (target === null || target === void 0 ? void 0 : target.end) || token.end,\n            };\n        nsAst.type = type;\n        nsAst.namespace = {\n            value: (prevAst === null || prevAst === void 0 ? void 0 : prevAst.value) || ``,\n            beforeComments: validNamespace ? beforeComments : [],\n            afterComments: validTarget\n                ? potentialAfterComments.map(helpers_1.createCommentAst)\n                : [],\n        };\n        nsAst.value = (target === null || target === void 0 ? void 0 : target.value) || ``;\n        nsAst.end = (target === null || target === void 0 ? void 0 : target.end) || token.end;\n        // set invalid\n        if (invalid) {\n            nsAst.namespace.invalid = invalid;\n        }\n        // add ast if not modified\n        if (!prevAst) {\n            ast.push(nsAst);\n        }\n    }\n    else if (token.type === \"(\") {\n        const prev = (0, core_1.last)(ast);\n        const res = [];\n        // handle nth selector\n        if (prev &&\n            prev.type === `pseudo_class` &&\n            nth_parser_1.NthParser.isNthPseudoClass(prev.value) &&\n            s.peek().type !== `)`) {\n            // collect \"An+B of\" expression\n            const nthSelector = (0, helpers_1.createEmptyNth)();\n            nthSelector.start = s.peek().start;\n            res.push(nthSelector);\n            const nthParser = new nth_parser_1.NthParser(nthSelector, s);\n            s.run((token) => {\n                if (nthParser.state === `selector`) {\n                    // got to selector, push back and stop\n                    s.back();\n                    return false;\n                }\n                return nthParser.handleToken(token);\n            }, nthSelector, source);\n            // setup next selector\n            if (s.peek().type !== `)`) {\n                nthSelector.end = ((_r = (0, core_1.last)(nthSelector.nodes)) === null || _r === void 0 ? void 0 : _r.end) || nthSelector.start;\n                // add \"of\" selector\n                const newSelector = (0, helpers_1.createEmptySelector)();\n                newSelector.start = nthSelector.end;\n                res.push(newSelector);\n            }\n        }\n        // get all tokens until closed\n        s.run((token, selectors) => {\n            var _a, _b;\n            if (token.type === \")\") {\n                const currentSelector = (0, core_1.last)(selectors);\n                if (currentSelector) {\n                    currentSelector.end =\n                        (_b = (_a = (0, core_1.last)(currentSelector.nodes)) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : currentSelector.start;\n                }\n                return false;\n            }\n            return handleToken(token, selectors, source, s);\n        }, res, source);\n        const ended = s.peek(0);\n        if (!prev ||\n            \"nodes\" in prev ||\n            prev.type === \"invalid\" ||\n            prev.type === \"combinator\" ||\n            prev.type === \"comment\" ||\n            prev.type === \"nth_step\" ||\n            prev.type === \"nth_dash\" ||\n            prev.type === \"nth_offset\" ||\n            prev.type === \"nth_of\" ||\n            ended.type !== \")\") {\n            ast.push({\n                type: \"invalid\",\n                value: (0, core_1.getText)([token, ended], undefined, undefined, source),\n                start: token.start,\n                end: (_s = ended === null || ended === void 0 ? void 0 : ended.end) !== null && _s !== void 0 ? _s : s.peekBack().end,\n            });\n        }\n        else {\n            if (res.length) {\n                const lastSelector = (0, core_1.last)(res);\n                (0, helpers_1.trimCombinators)(lastSelector);\n            }\n            prev.nodes = res;\n            prev.end = ended.end;\n        }\n    }\n    else if ((0, core_1.isComment)(token.type)) {\n        ast.push((0, helpers_1.createCommentAst)(token));\n    }\n    else if (token.type === \",\") {\n        const selector = (0, core_1.last)(selectors);\n        selector.end = token.start;\n        (0, helpers_1.trimCombinators)(selector);\n        const newSelector = (0, helpers_1.createEmptySelector)();\n        if (s.done()) {\n            newSelector.start = token.end;\n            newSelector.end = token.end;\n        }\n        else {\n            newSelector.start = s.peek().start;\n        }\n        selectors.push(newSelector);\n    }\n    else if (token.type === \"&\") {\n        ast.push({\n            type: \"nesting\",\n            value: \"&\",\n            start: token.start,\n            end: token.end,\n        });\n    }\n    else {\n        ast.push({\n            type: \"invalid\",\n            value: token.value,\n            start: token.start,\n            end: token.end,\n        });\n    }\n    if (s.done()) {\n        currentSelector.end =\n            (_u = (_t = (0, core_1.last)(currentSelector.nodes)) === null || _t === void 0 ? void 0 : _t.end) !== null && _u !== void 0 ? _u : currentSelector.start;\n        (0, helpers_1.trimCombinators)(currentSelector);\n    }\n}\n//# sourceMappingURL=selector-parser.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/selector-parser.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/stringify.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/stringify.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringifySelectorAst = void 0;\nconst nth_parser_1 = __webpack_require__(/*! ./nth-parser */ \"./node_modules/@tokey/css-selector-parser/dist/nth-parser.js\");\nfunction stringifySelectorAst(value) {\n    return \"length\" in value ? stringifySelectors(value) : stringifyNode(value);\n}\nexports.stringifySelectorAst = stringifySelectorAst;\nconst printers = {\n    id: (node) => `#${node.value}${stringifyNested(node)}`,\n    class: (node) => `.${node.dotComments.map(stringifyNode).join(\"\")}${node.value}${stringifyNested(node)}`,\n    type: (node) => `${stringifyNamespace(node)}${node.value}${stringifyNested(node)}`,\n    combinator: (node) => `${node.before}${node.value}${node.after}`,\n    attribute: (node) => `[${node.value}]${stringifyNested(node)}`,\n    pseudo_class: (node) => `:${node.colonComments.map(stringifyNode).join(\"\")}${node.value}${stringifyNested(node)}`,\n    pseudo_element: (node) => `:${node.colonComments.first\n        .map(stringifyNode)\n        .join(\"\")}:${node.colonComments.second.map(stringifyNode).join(\"\")}${node.value}${stringifyNested(node)}`,\n    comment: ({ before, value, after }) => `${before}${value}${after}`,\n    universal: (node) => `${stringifyNamespace(node)}${node.value}${stringifyNested(node)}`,\n    nesting: (node) => `${node.value}${stringifyNested(node)}`,\n    selector: (node) => `${node.before}${node.nodes.map(stringifyNode).join(\"\")}${node.after}`,\n    compound_selector: (node) => `${node.before}${node.nodes.map(stringifyNode).join(\"\")}${node.after}`,\n    invalid: (node) => node.value,\n    nth: (node) => `${node.before}${node.nodes.map(stringifyNode).join(\"\")}${node.after}`,\n    nth_step: ({ before, value, after }) => `${before}${value}${after}`,\n    nth_dash: ({ before, value, after }) => `${before}${value}${after}`,\n    nth_offset: ({ before, value, after }) => `${before}${value}${after}`,\n    nth_of: ({ before, value, after }) => `${before}${value}${after}`,\n};\nfunction stringifyNode(node) {\n    var _a, _b;\n    return (_b = (_a = printers[node.type]) === null || _a === void 0 ? void 0 : _a.call(printers, node)) !== null && _b !== void 0 ? _b : \"\";\n}\nfunction stringifySelectors(selectors) {\n    const result = [];\n    for (const node of selectors) {\n        result.push(stringifyNode(node));\n    }\n    return result.join(`,`);\n}\nfunction stringifyNested(node) {\n    var _a;\n    if (\"nodes\" in node) {\n        if ((_a = node.nodes) === null || _a === void 0 ? void 0 : _a.length) {\n            if (node.type === `pseudo_class` &&\n                nth_parser_1.NthParser.isNthPseudoClass(node.value)) {\n                const [nthNode, ...selectors] = node.nodes;\n                return `(${stringifyNode(nthNode)}${stringifySelectors(selectors)})`;\n            }\n            else {\n                return `(${stringifySelectors(node.nodes)})`;\n            }\n        }\n        else {\n            return `()`;\n        }\n    }\n    return \"\";\n}\nfunction stringifyNamespace({ namespace }) {\n    let ns = ``;\n    if (namespace) {\n        ns += namespace.value;\n        for (const comment of namespace.beforeComments) {\n            ns += printers.comment(comment);\n        }\n        ns += `|`;\n        for (const comment of namespace.afterComments) {\n            ns += printers.comment(comment);\n        }\n    }\n    return ns;\n}\n//# sourceMappingURL=stringify.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/stringify.js?");

/***/ }),

/***/ "./node_modules/@tokey/css-selector-parser/dist/tokenizer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tokey/css-selector-parser/dist/tokenizer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tokenizeSelector = void 0;\nconst core_1 = __webpack_require__(/*! @tokey/core */ \"./node_modules/@tokey/core/dist/index.js\");\nfunction tokenizeSelector(source, options = {}) {\n    const parseLineComments = false; // why would that be a choice?\n    return (0, core_1.tokenize)(source, {\n        isDelimiter,\n        isStringDelimiter(char, previousChar) {\n            return previousChar !== `\\\\` && (0, core_1.isStringDelimiter)(char);\n        },\n        isWhitespace: core_1.isWhitespace,\n        shouldAddToken: () => true,\n        createToken: core_1.createToken,\n        getCommentStartType: parseLineComments\n            ? core_1.getJSCommentStartType\n            : core_1.getMultilineCommentStartType,\n        isCommentEnd: core_1.isCommentEnd,\n        getUnclosedComment: core_1.getUnclosedComment,\n        offset: options.offset,\n    });\n}\nexports.tokenizeSelector = tokenizeSelector;\nconst isDelimiter = (char, previousChar) => previousChar !== \"\\\\\" &&\n    (char === \"[\" ||\n        char === \"]\" ||\n        char === \"(\" ||\n        char === \")\" ||\n        char === \",\" ||\n        char === \"*\" ||\n        char === \"|\" ||\n        char === \":\" ||\n        char === \".\" ||\n        char === \"#\" ||\n        char === \">\" ||\n        char === \"~\" ||\n        char === \"+\" ||\n        char === \"{\" ||\n        char === \"}\" ||\n        char === \"&\");\n//# sourceMappingURL=tokenizer.js.map\n\n//# sourceURL=webpack://Translator/./node_modules/@tokey/css-selector-parser/dist/tokenizer.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_ui__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://Translator/./src/index.ts?");

/***/ }),

/***/ "./src/translate.ts":
/*!**************************!*\
  !*** ./src/translate.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"translate\": () => (/* binding */ translate)\n/* harmony export */ });\n/* harmony import */ var _tokey_css_selector_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tokey/css-selector-parser */ \"./node_modules/@tokey/css-selector-parser/dist/index.js\");\n/* harmony import */ var _tokey_css_selector_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tokey_css_selector_parser__WEBPACK_IMPORTED_MODULE_0__);\n\nconst COMPOUND_SELECTOR = 'compound_selector';\nconst CLASS = 'class';\nconst UNIVERSAL = 'universal';\nconst TYPE = 'type';\nconst addSingleQuotes = (items) => items.map((item) => `'${item}'`);\nconst isVowelPrefix = (str) => ['a', 'e', 'o', 'i', 'u'].includes(str[0]);\nconst getClassesString = (classes) => classes.length > 1 ? `classes ${joiner(classes)}` : `class ${classes[0]}`;\nfunction translate(selector) {\n    const selectorList = (0,_tokey_css_selector_parser__WEBPACK_IMPORTED_MODULE_0__.parseCssSelector)(selector);\n    const compoundSelectorList = (0,_tokey_css_selector_parser__WEBPACK_IMPORTED_MODULE_0__.groupCompoundSelectors)(selectorList);\n    const translations = [];\n    for (const topLevelSelectors of compoundSelectorList) {\n        const translation = [];\n        for (const selector of topLevelSelectors.nodes.reverse()) {\n            if (selector.type === COMPOUND_SELECTOR) {\n                const { classes, hasUniversal, element } = iterateCompoundSelector(selector);\n                if (element) {\n                    isVowelPrefix(element) ? translation.push('An') : translation.push('A');\n                    translation.push(`'<${element}>' element`);\n                }\n                if (classes.length) {\n                    if (!element) {\n                        translation.push('an element');\n                    }\n                    translation.push(`with ${getClassesString(addSingleQuotes(classes))}`);\n                }\n                if (hasUniversal) {\n                    translation.push('any element');\n                }\n            }\n            if (selector.type === 'combinator') {\n                translation.push('within');\n            }\n        }\n        translations.push(translation.join(' '));\n    }\n    return capitalizeFirstLetter(joiner(translations));\n}\nfunction iterateCompoundSelector(compoundSelector) {\n    const classes = new Set();\n    let hasUniversal = false;\n    let element;\n    for (const node of compoundSelector.nodes) {\n        if (node.type === CLASS) {\n            classes.add(node.value);\n        }\n        if (node.type === TYPE) {\n            element = node.value;\n        }\n        if (node.type === UNIVERSAL) {\n            hasUniversal = true;\n        }\n    }\n    return { classes: Array.from(classes), hasUniversal, element };\n}\nfunction capitalizeFirstLetter(str) {\n    if (str === null || str === void 0 ? void 0 : str.length) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n    return str;\n}\nfunction joiner(items) {\n    if (items.length === 2) {\n        return `${items[0]} and ${items[1]}`;\n    }\n    if (items.length > 2) {\n        return `${items.slice(0, -1).join(', ')} and ${items.at(-1)}`;\n    }\n    return items[0];\n}\n\n\n//# sourceURL=webpack://Translator/./src/translate.ts?");

/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _translate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./translate */ \"./src/translate.ts\");\n\nclass App {\n    constructor() {\n        this.form = document.querySelector('#form');\n        this.input = document.querySelector('#selector-input');\n        this.result = document.querySelector('#result');\n        this.fillInputFromURL();\n        this.form.addEventListener('submit', (event) => {\n            event.preventDefault();\n            this.translate(this.input.value);\n        });\n    }\n    translate(value) {\n        this.result.innerText = (0,_translate__WEBPACK_IMPORTED_MODULE_0__.translate)(value);\n        this.updateQueryParam(value);\n    }\n    updateQueryParam(value) {\n        const params = new URLSearchParams(window.location.search);\n        if (!value) {\n            params.delete('s');\n        }\n        else {\n            params.set('s', encodeURIComponent(value));\n        }\n        history.pushState(null, '', '?' + params.toString());\n    }\n    fillInputFromURL() {\n        //TODO:\n        // const params = new URLSearchParams(window.location.search);\n        // if (params.has('s')) {\n        //     try {\n        //         this.$.input.value = decodeURIComponent(params.get('s'));\n        //         this.displayResults(this.$.input.value);\n        //     } catch (error) {\n        //         this.clear('');\n        //     }\n        // }\n    }\n}\nwindow.App = new App();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n\n//# sourceURL=webpack://Translator/./src/ui.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});